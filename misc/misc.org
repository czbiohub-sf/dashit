#+TITLE: special ops crispr tools miscellaneous
#+AUTHOR: David Dynerman
#+EMAIL: david.dynerman@czbiohub.org
#+DATE:

* =score_guides.py=
This utility takes as input:

1. a CSV list of guides (e.g., output of =optimize_guides.go=), 
2. a sites -> reads map file, as generated by =crispr_sites=

and reports how many reads in the original FASTQ file are hit by
guides (e.g., would be supressed if we DASHed with a library
consisting of guides)

#+BEGIN_SRC python :tangle score_guides/score_guides.py
#!/usr/bin/env python3
import sys
import re

if __name__ == '__main__':
    sites_to_reads_filename = sys.argv[1]
    sites_filename = sys.argv[2]

    sites_to_reads = {}

    largest_read_idx = 0

    with open(sites_to_reads_filename, 'r') as sites_to_reads_file:
        lines = sites_to_reads_file.readlines()

        num_reads = None

        match = re.search(r'Total.+?(\d+)', lines[0])
        if match is not None:
            num_reads = int(match.group(1))
	    lines = lines[1:]

        for line in lines:
            line = line.split()
            sites_to_reads[line[0]] = [int(read) for read in line[1:]]
            if max(sites_to_reads[line[0]]) > largest_read_idx:
                largest_read_idx = max(sites_to_reads[line[0]])

    # If we didn't pickup the number of reads from the first line in
    # the file (e.g., processing an older file) use largest_read_idx
    # as the number of reads
    if num_reads is None:
        num_reads = largest_read_idx
        
    reads_covered = {}
    useless_guides = []
    
    with open(sites_filename, 'r') as sites_file:
        for line in sites_file.readlines()[2:]:
            site = line.split(',')[0].strip(' ')

            if site not in sites_to_reads:
                useless_guides.append(site)
                continue
            
            for read in sites_to_reads[site]:
                if read in reads_covered:
                    reads_covered[read] += 1
                else:
                    reads_covered[read] = 1

    print("{} will hit {}/{} = {:2.2g}% reads in {}, {} guides hit no reads".format(sites_filename, len(reads_covered.keys()), num_reads, len(reads_covered.keys())/float(num_reads) * 100, sites_to_reads_filename, len(useless_guides)))
#+END_SRC

** Guide scoring for original DASH dataset
This section runs =score_guides.py= on a set of DASHed and un-DASHed to compare how the automated guide design performed.

#+NAME: base_path
/Users/dynerman/work/special_ops_crispr_tools/data

#+NAME: guides_filename
../../dashit_data/NID0093_CSF_GTTGCTC-GATTCGC_L00C_R1_001_guides.txt

#+NAME: comparison_filenames
| Crypt_DASH/D01_S37_L006_R1_001.fastq.gz | Crypt_noDASH/C04_S28_L006_R1_001.fastq.gz |
| Bal_DASH/C09_S33_L006_R1_001.fastq.gz   | Bal_noDASH/C02_S26_L006_R1_001.fastq.gz   |
| Tso_DASH/D02_S38_L006_R1_001.fastq.gz   | Tso_noDASH/C05_S29_L006_R1_001.fastq.gz   |

#+BEGIN_SRC python :var comparison_filenames=comparison_filenames base_path=base_path guides_filename=guides_filename :results output 
import os
from subprocess import call

base_path = base_path.strip()
guides_filename = guides_filename.strip()

for dashed_filename, undashed_filename in comparison_filenames:
    full_dashed_filename = os.path.join(base_path, dashed_filename)
    full_undashed_filename = os.path.join(base_path, undashed_filename)

    full_guides_filename = os.path.join(base_path, guides_filename)

    print('gunzip {}'.format(dashed_filename))
    call("gunzip {}".format(full_dashed_filename), shell=True)
    call("gunzip {}".format(full_undashed_filename), shell=True)    

    # No .fastq.gz
    full_dashed_basename = os.path.splitext(os.path.splitext(full_dashed_filename)[0])[0]
    full_undashed_basename = os.path.splitext(os.path.splitext(full_undashed_filename)[0])[0]

    print('convert {0}.fastq -> {0}.fasta'.format(full_dashed_basename))
    call('seqtk seq -A {0}.fastq > {0}.fasta'.format(full_dashed_basename), shell=True)
    
    print('convert {0}.fastq -> {0}.fasta'.format(full_undashed_basename))
    call('seqtk seq -A {0}.fastq > {0}.fasta'.format(full_undashed_basename), shell=True)

    print('crispr_sites {}'.format(full_dashed_basename))
    call("cat {} | ../crispr_sites/crispr_sites > {}_sites_to_reads.txt".format(full_dashed_basename + '.fasta', full_dashed_basename), shell=True)

    print('crispr_sites {}'.format(full_undashed_basename))
    call("cat {} | ../crispr_sites/crispr_sites > {}_sites_to_reads.txt".format(full_undashed_basename + '.fasta', full_undashed_basename), shell=True)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :var comparison_filenames=comparison_filenames base_path=base_path guides_filename=guides_filename :results output 
import os
from subprocess import call

base_path = base_path.strip()
guides_filename = guides_filename.strip()

for dashed_filename, undashed_filename in comparison_filenames:
    full_dashed_filename = os.path.join(base_path, dashed_filename)
    full_undashed_filename = os.path.join(base_path, undashed_filename)

    full_guides_filename = os.path.join(base_path, guides_filename)

    # No .fastq.gz
    full_dashed_basename = os.path.splitext(os.path.splitext(full_dashed_filename)[0])[0]
    full_undashed_basename = os.path.splitext(os.path.splitext(full_undashed_filename)[0])[0]
    
    print('score_guides.py {}'.format(full_dashed_basename))
    call("source ~/.virtualenvs/dashdat/bin/activate && python score_guides/score_guides.py {}_sites_to_reads.txt {} > {}.score".format(full_dashed_basename, full_guides_filename, full_dashed_basename), shell=True)

    print('score_guides.py {}'.format(full_undashed_basename))
    call("source ~/.virtualenvs/dashdat/bin/activate && python score_guides/score_guides.py {}_sites_to_reads.txt {} > {}.score".format(full_undashed_basename, full_guides_filename, full_undashed_basename), shell=True)
#+END_SRC

#+RESULTS:
: score_guides.py /Users/dynerman/work/special_ops_crispr_tools/data/Crypt_DASH/D01_S37_L006_R1_001
: score_guides.py /Users/dynerman/work/special_ops_crispr_tools/data/Crypt_noDASH/C04_S28_L006_R1_001
: score_guides.py /Users/dynerman/work/special_ops_crispr_tools/data/Bal_DASH/C09_S33_L006_R1_001
: score_guides.py /Users/dynerman/work/special_ops_crispr_tools/data/Bal_noDASH/C02_S26_L006_R1_001
: score_guides.py /Users/dynerman/work/special_ops_crispr_tools/data/Tso_DASH/D02_S38_L006_R1_001
: score_guides.py /Users/dynerman/work/special_ops_crispr_tools/data/Tso_noDASH/C05_S29_L006_R1_001

#+BEGIN_SRC python :var comparison_filenames=comparison_filenames base_path=base_path guides_filename=guides_filename :results file
from matplotlib import pyplot as plt
import re
import os
import numpy as np

base_path = base_path.strip()

reads_hit = {}

for dashed_filename, undashed_filename in comparison_filenames:
    full_dashed_filename = os.path.join(base_path, dashed_filename)
    full_undashed_filename = os.path.join(base_path, undashed_filename)
    full_dashed_basename = os.path.splitext(os.path.splitext(full_dashed_filename)[0])[0]
    full_undashed_basename = os.path.splitext(os.path.splitext(full_undashed_filename)[0])[0]
    dataset_name = re.search(r'(.*)_DASH', os.path.split(os.path.split(full_dashed_basename)[-2])[-1]).group(1)
    with open(full_dashed_basename + '.score', 'r') as dashed_score:
        lines = dashed_score.readlines()
        if len(lines) != 1:
            raise ValueError('score file {} not in expected format'.format(full_dashed_basename + '.score'))
        match = re.search(r'(\d+)/(\d+)', lines[0])
        if match is None:
            raise ValueError('score file {} not in expected format'.format(full_dashed_basename + '.score'))
        dashed_reads_hit = (int(match.group(1)), int(match.group(2)))
    with open(full_undashed_basename + '.score', 'r') as undashed_score:
        lines = undashed_score.readlines()
        if len(lines) != 1:
            raise ValueError('score file {} not in expected format'.format(full_undashed_basename + '.score'))
        match = re.search(r'(\d+)/(\d+)', lines[0])
        if match is None:
            raise ValueError('score file {} not in expected format'.format(full_undashed_basename + '.score'))
        undashed_reads_hit = (int(match.group(1)), int(match.group(2)))

    reads_hit[dataset_name] = (dashed_reads_hit[0] / dashed_reads_hit[1],
                               undashed_reads_hit[0] / undashed_reads_hit[1])


fig, ax = plt.subplots()

ax.set_title('DASH hits for 100 automated guides from 93')

width = 0.35

dataset_names = list(reads_hit.keys())
idxs = np.arange(len(dataset_names))

dashed_bars = ax.bar(idxs, [ reads_hit[k][0] for k in dataset_names ], width)
undashed_bars = ax.bar(idxs + width, [ reads_hit[k][1] for k in dataset_names ], width)

ax.set_xticks(idxs + width / 2)
ax.set_xticklabels(dataset_names)

ax.set_ylabel('fraction of reads hit')
ax.legend((dashed_bars[0], undashed_bars[0]), ('DASH', 'noDASH'))
fig.savefig('dash_hits.png')
return 'dash_hits.png'
#+END_SRC

#+RESULTS:
[[file:dash_hits.png]]



* =compare_guides.py=

#+BEGIN_SRC python :tangle compare_guides/compare_guides.py
import sys
import os

def diff_guide_files(guide_l_name, guide_r_name):
    guides_l = []

    with open('../../../dashit_data/filt_99_99_99W_H2O_S14_RR1_guides.csv', 'r') as guides_file:
        for line in guides_file.readlines()[1:]:
            guides_l.append(line.split()[0][:-1])

    guides_r = []
        
    with open('../../../dashit_data/W_H2O_S14_R1_001_guides.csv', 'r') as guides_file:
        for line in guides_file.readlines()[1:]:
            guides_r.append(line.split()[0][:-1])

    intersection = set(guides_l) & set(guides_r)

    guides_l_unique = set(guides_l) - intersection

    guides_r_unique = set(guides_r) - intersection

    return intersection, guides_l_unique, guides_r_unique

if __name__ == '__main__':
    if len(sys.argv) < 3:
        sys.stderr.write('Usage: python compare_guides.py guide_file_l.csv guide_file_r.csv\n')
        sys.exit(1)

    intersection, guides_l_unique, guides_r_unique = diff_guide_files(sys.argv[1], sys.argv[1])

    short_l_name = os.path.split(sys.argv[1])[-1]
    short_r_name = os.path.split(sys.argv[2])[-1]
    
    print('Guides common to {} and {}:'.format(short_l_name, short_r_name))
    for guide in intersection:
        print('\t{}'.format(guide))

    print('\n\nGuides only in {}'.format(short_l_name))
    for guide in guides_l_unique:
        print('\t{}'.format(guide))

    print('\n\nGuides only in {}'.format(short_r_name))
    for guide in guides_r_unique:
        print('\t{}'.format(guide))
    
    print('\n\nNumber of guides in common: \t\t\t{}'.format(len(intersection)))
    print('Number of guides in {} and not in {}: \t\t\t{}'.format(short_l_name, short_r_name, len(guides_l_unique)))
    print('Number of guides in {} and not in {}: \t\t\t{}'.format(short_r_name, short_l_name, len(guides_r_unique)))    


#+END_SRC
