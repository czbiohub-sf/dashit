#+TITLE: special ops crispr tools miscellaneous
#+AUTHOR: David Dynerman
#+EMAIL: david.dynerman@czbiohub.org
#+DATE:

* =score_guides.py=
This utility takes as input:

1. a CSV list of guides (e.g., output of =optimize_guides.go=), 
2. a sites -> reads map file, as generated by =crispr_sites=

and reports how many reads in the original FASTQ file are hit by
guides (e.g., would be supressed if we DASHed with a library
consisting of guides)

#+BEGIN_SRC python :tangle score_guides/score_guides.py
import sys

if __name__ == '__main__':
    sites_to_reads_filename = sys.argv[1]
    sites_filename = sys.argv[2]

    sites_to_reads = {}

    largest_read_idx = 0
      
    with open(sites_to_reads_filename, 'r') as sites_to_reads_file:
        for line in sites_to_reads_file.readlines():
            line = line.split()
            sites_to_reads[line[0]] = [int(read) for read in line[1:]]
            if max(sites_to_reads[line[0]]) > largest_read_idx:
                largest_read_idx = max(sites_to_reads[line[0]])

    reads_covered = {}
    useless_guides = []
    
    with open(sites_filename, 'r') as sites_file:
        for line in sites_file.readlines()[1:]:
            site = line.split()[0][:-1]

            if site not in sites_to_reads:
                useless_guides.append(site)
                continue
            
            for read in sites_to_reads[site]:
                if read in reads_covered:
                    reads_covered[read] += 1
                else:
                    reads_covered[read] = 1
          
    print("These guides will hit {}/{} = {:2.2g}% reads, {} guides hit no reads".format(len(reads_covered.keys()), largest_read_idx, len(reads_covered.keys())/largest_read_idx * 100, len(useless_guides)))
#+END_SRC

** Guide scoring for original DASH dataset

#+NAME: base_path
/Users/dynerman/work/special_ops_crispr_tools/data

#+NAME: guides_filename
../../dashit_data/NID0093_CSF_GTTGCTC-GATTCGC_L00C_R1_001_guides.txt

#+NAME: comparison_filenames
| Crypt_DASH/D01_S37_L006_R1_001.fastq.gz | Crypt_noDASH/C04_S28_L006_R1_001.fastq.gz |
| Bal_DASH/C09_S33_L006_R1_001.fastq.gz   | Bal_noDASH/C02_S26_L006_R1_001.fastq.gz   |
| Tso_DASH/D02_S38_L006_R1_001.fastq.gz   | Tso_noDASH/C05_S29_L006_R1_001.fastq.gz   |

#+BEGIN_SRC python :var comparison_filenames=comparison_filenames base_path=base_path guides_filename=guides_filename :results output 
import os
from subprocess import call

base_path = base_path.strip()
guides_filename = guides_filename.strip()

for dashed_filename, undashed_filename in comparison_filenames:
    full_dashed_filename = os.path.join(base_path, dashed_filename)
    full_undashed_filename = os.path.join(base_path, undashed_filename)

    full_guides_filename = os.path.join(base_path, guides_filename)

    print('gunzip {}'.format(dashed_filename))
    call("gunzip {}".format(full_dashed_filename), shell=True)
    call("gunzip {}".format(full_undashed_filename), shell=True)    

    # No .fastq.gz
    full_dashed_basename = os.path.splitext(os.path.splitext(full_dashed_filename)[0])[0]
    full_undashed_basename = os.path.splitext(os.path.splitext(full_undashed_filename)[0])[0]

    print('convert {0}.fastq -> {0}.fasta'.format(full_dashed_basename))
    call('seqtk seq -A {0}.fastq > {0}.fasta'.format(full_dashed_basename), shell=True)
    
    print('convert {0}.fastq -> {0}.fasta'.format(full_undashed_basename))
    call('seqtk seq -A {0}.fastq > {0}.fasta'.format(full_undashed_basename), shell=True)

    print('crispr_sites {}'.format(full_dashed_basename))
    call("cat {} | ../crispr_sites/crispr_sites > {}_sites_to_reads.txt".format(full_dashed_basename + '.fasta', full_dashed_basename), shell=True)

    print('crispr_sites {}'.format(full_undashed_basename))
    call("cat {} | ../crispr_sites/crispr_sites > {}_sites_to_reads.txt".format(full_undashed_basename + '.fasta', full_undashed_basename), shell=True)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :var comparison_filenames=comparison_filenames base_path=base_path guides_filename=guides_filename :results output 
import os
from subprocess import call

base_path = base_path.strip()
guides_filename = guides_filename.strip()

for dashed_filename, undashed_filename in comparison_filenames:
    full_dashed_filename = os.path.join(base_path, dashed_filename)
    full_undashed_filename = os.path.join(base_path, undashed_filename)

    full_guides_filename = os.path.join(base_path, guides_filename)

    # No .fastq.gz
    full_dashed_basename = os.path.splitext(os.path.splitext(full_dashed_filename)[0])[0]
    full_undashed_basename = os.path.splitext(os.path.splitext(full_undashed_filename)[0])[0]
    
    print('score_guides.py {}'.format(full_dashed_basename))
    call("source ~/.virtualenvs/dashdat/bin/activate && python score_guides/score_guides.py {}_sites_to_reads.txt {} > {}.score".format(full_dashed_basename, full_guides_filename, full_dashed_basename), shell=True)

    print('score_guides.py {}'.format(full_undashed_basename))
    call("source ~/.virtualenvs/dashdat/bin/activate && python score_guides/score_guides.py {}_sites_to_reads.txt {} > {}.score".format(full_undashed_basename, full_guides_filename, full_undashed_basename), shell=True)
#+END_SRC

#+RESULTS:
: score_guides.py /Users/dynerman/work/special_ops_crispr_tools/data/Crypt_DASH/D01_S37_L006_R1_001
: score_guides.py /Users/dynerman/work/special_ops_crispr_tools/data/Crypt_noDASH/C04_S28_L006_R1_001
: score_guides.py /Users/dynerman/work/special_ops_crispr_tools/data/Bal_DASH/C09_S33_L006_R1_001
: score_guides.py /Users/dynerman/work/special_ops_crispr_tools/data/Bal_noDASH/C02_S26_L006_R1_001
: score_guides.py /Users/dynerman/work/special_ops_crispr_tools/data/Tso_DASH/D02_S38_L006_R1_001
: score_guides.py /Users/dynerman/work/special_ops_crispr_tools/data/Tso_noDASH/C05_S29_L006_R1_001

#+BEGIN_SRC python :var comparison_filenames=comparison_filenames base_path=base_path guides_filename=guides_filename :results file
from matplotlib import pyplot as plt
import re
import os
import numpy as np

base_path = base_path.strip()

reads_hit = {}

for dashed_filename, undashed_filename in comparison_filenames:
    full_dashed_filename = os.path.join(base_path, dashed_filename)
    full_undashed_filename = os.path.join(base_path, undashed_filename)
    full_dashed_basename = os.path.splitext(os.path.splitext(full_dashed_filename)[0])[0]
    full_undashed_basename = os.path.splitext(os.path.splitext(full_undashed_filename)[0])[0]
    dataset_name = re.search(r'(.*)_DASH', os.path.split(os.path.split(full_dashed_basename)[-2])[-1]).group(1)
    with open(full_dashed_basename + '.score', 'r') as dashed_score:
        lines = dashed_score.readlines()
        if len(lines) != 1:
            raise ValueError('score file {} not in expected format'.format(full_dashed_basename + '.score'))
        match = re.search(r'(\d+)/(\d+)', lines[0])
        if match is None:
            raise ValueError('score file {} not in expected format'.format(full_dashed_basename + '.score'))
        dashed_reads_hit = (int(match.group(1)), int(match.group(2)))
    with open(full_undashed_basename + '.score', 'r') as undashed_score:
        lines = undashed_score.readlines()
        if len(lines) != 1:
            raise ValueError('score file {} not in expected format'.format(full_undashed_basename + '.score'))
        match = re.search(r'(\d+)/(\d+)', lines[0])
        if match is None:
            raise ValueError('score file {} not in expected format'.format(full_undashed_basename + '.score'))
        undashed_reads_hit = (int(match.group(1)), int(match.group(2)))

    reads_hit[dataset_name] = (dashed_reads_hit[0] / dashed_reads_hit[1],
                               undashed_reads_hit[0] / undashed_reads_hit[1])


fig, ax = plt.subplots()

ax.set_title('DASH hits for 100 automated guides from 93')

width = 0.35

dataset_names = list(reads_hit.keys())
idxs = np.arange(len(dataset_names))

dashed_bars = ax.bar(idxs, [ reads_hit[k][0] for k in dataset_names ], width)
undashed_bars = ax.bar(idxs + width, [ reads_hit[k][1] for k in dataset_names ], width)

ax.set_xticks(idxs + width / 2)
ax.set_xticklabels(dataset_names)

ax.set_ylabel('fraction of reads hit')
ax.legend((dashed_bars[0], undashed_bars[0]), ('DASH', 'noDASH'))
fig.savefig('dash_hits.png')
return 'dash_hits.png'
#+END_SRC

#+RESULTS:
[[file:dash_hits.png]]


