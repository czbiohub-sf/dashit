# -*- org-confirm-babel-evaluate: nil; -*-
#+TITLE: DASHit-reads
#+AUTHOR: David Dynerman
#+EMAIL: david.dynerman@czbiohub.org
#+OPTIONS:
#+PROPERTY: header-args:org :exports results :results replace

* Offtarget and quality filtering
:PROPERTIES:
:header-args:python: :tangle dashit_reads/dashit_reads_filter.py :noweb yes
:END:
#+NAME: doc:dashit-reads-filter
#+BEGIN_SRC org
DASHit-reads-filter: Filter candidate guides for offtarget and quality.

Given an offtarget file and quality parameters, remove candidate
guides from a sites-to-reads file that hit offtargets or are of low
quality.

=DASHit-reads= performs offtarget and quality filtering on the
sites-to-reads file (output of =crispr_sites -r=): it simply removes
lines from this file that match offtargets or have low quality.
#+END_SRC

#+BEGIN_SRC python
"""
<<doc:dashit-reads-filter>>
"""
import argparse
import logging
import os
from datetime import datetime
import re
import subprocess
import signal
import sys
import threading
import traceback
import select
import requests
from requests import ConnectionError
from ash import flash
from pathlib import Path
from tqdm import tqdm, trange
from collections import defaultdict

log = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

def get_offtargets(targets, c5, c10, c20):
    """Get offtargets from a locally running offtarget server

    Parameters
    ----------
    targets : list
        list of 20-mers to match against offtarget list
    c5, c10, c20 : int
        radius of match, see command line documentation
    
    Returns
    -------
    dict
       dict keyed on elements of targets, with boolean value
       indicating if they were offtarget or not
    """

    # Limits on how long URLs can be for GET requests
    batch_size = 20000

    offtargets = {}
    
    try:
        for i in range(0, len(targets), batch_size):
            url = "http://localhost:8080/search?targets=%s&limits=%s"
            url = url % (",".join(map(str, targets[i:i+batch_size])), ",".join(map(str, [c5, c10, c20])))
            offtargets.update(parse_offtarget_server_response(requests.get(url, timeout=600)))
    except ConnectionError:
        log.error('Error contacting offtarget server')
        raise

    return offtargets
#+END_SRC
** =filter_sites_poor_structure=
#+NAME: doc:filter_sites_poor_structure
#+BEGIN_SRC org
Filter CRISPR sites due to poor structural reasons.

A site will be removed if any of the following are true:

1. G/C frequency too high (> 15/20) or too low (< 5/20)
2. /Homopolymer/: more than 5 consecutive repeated nucleotides
3. /Dinucleotide repeats/: the same two nucelotides alternate for > 3
   repeats
4. /Hairpin/: complementary subsequences near the start and end of a
   site can bind, causing a hairpin
#+END_SRC

#+BEGIN_SRC python
def filter_sites_poor_structure(sequences, filtered_sites, filter_parms):
    """
    <<doc:filter_sites_poor_structure>>

    Parameters
    ----------
    sequences : list of `common.Gene`
	the input sequences with CRISPR targets identified
    filtered_sites : dict
	dict containing which sites have been filtered
    filter_parms : dict
	parameters controlling poor structure filtering,
	see `flash.poor_structure`
    """

    log.info('filtering sites for poor structure '
	     'with parms {}'.format(filter_parms))

    initial_num_filtered = len(filtered_sites)

    filtered_sites.update(flash.poor_structure(sequences, filter_parms))

    log.info('removed {} sites from consideration due to poor '
	     'structure'.format(len(filtered_sites) - initial_num_filtered))
#+END_SRC

** =launch_offtarget_server=
#+NAME: doc:launch_offtarget_server
#+BEGIN_SRC org
Launch the off target filtering server.
#+END_SRC

#+BEGIN_SRC python
def launch_offtarget_server(offtarget_filename):
    """<<doc:launch_offtarget_server>>

    Parameters
    ----------
    offtarget_filename : str
	filename containing off target CRISPR sites, as generated by
	`special_ops_crispr_tools/crispr_sites`

    Returns
    -------
    `subprocess.Popen` the offtarget server launched
    as a child process. Returns None if an error occurs while
    starting the server.
    """

    if check_offtarget_running():
        log.error('An on/offtarget filtering server is already running on the '
                  'default port. Kill all offtarget servers before running '
                  'dashit-filter-reads')
        log.error('e.g., killall offtarget')
        return None
    
    offtarget_env = os.environ.copy()
    offtarget_env['HOST'] = 'file://' + str(Path(offtarget_filename).resolve())

    log.info('Launching offtarget with HOST = {}'.format(offtarget_env['HOST']))

    proc = subprocess.Popen(['/usr/bin/env', 'offtarget'], env=offtarget_env,
                            stderr=subprocess.STDOUT, stdout=subprocess.PIPE)

    stdout_poll = select.poll()
    stdout_poll.register(proc.stdout)

    # To detect if the offtarget server is running, we read from the
    # stdout/stderr of the offtarget process to see if the expected
    # lines of output are present in the expected order
    expected_lines = [ 'ingesting', 'computing', 'index',
                       'max', 'occupied', 'starting server']

    server_started = False
    
    while server_started is False:
        i = 0
        output_lines = []
        if stdout_poll.poll(1):
            for line in proc.stdout:
                line = str(line, 'utf-8')
                output_lines.append(line)

                if not expected_lines[i] in line:
                    log.error("Error while launching offtarget server")
                    log.error("Expected the offtarget server to output a "
                              f"line containing {expected_lines[i]}, but the "
                              f"offtarget process output {line}")
                    log.error("Complete output from the offtarget "
                              f"process: {output_lines}")

                    # Attempt to display better help messages
                    if 'env' in line:
                        log.error("Is offtarget in your path and working?")
                    elif 'Query' in line:
                        # The query line reports which Query caused an
                        # error, read the next line to see what the
                        # error actually was
                        next_line = str(proc.stdout.readline(), 'utf-8')

                        if ('received target query for string with length != 20'
                            in next_line):
                            # This error occurs when a file with
                            # something other than 20-mers is fed into
                            # the offtarget server
                            log.error(f"{offtarget_filename} is not the right "
                                      "format. Does this file contain only "
                                      "20-mers? It should be the output of "
                                      "crispr_sites run on a FASTA file")

                    proc.terminate()
                    return None
                else:
                    log.info(f"Correct offtarget server output: {line.strip()}")

                i += 1

                if i >= len(expected_lines):
                    log.info("Offtarget succesfully started")
                    server_started = True
                    break

    return proc
#+END_SRC

** =check_offtarget_alive=
#+NAME: doc:check_offtarget_alive
#+BEGIN_SRC org
Check that the offtarget server process is running. Log errors if not.
#+END_SRC

#+BEGIN_SRC python
def check_offtarget_alive(offtarget_proc):
    """
    <<doc:check_offtarget_alive>>

    Parameters
    ----------
    offtarget_proc : `subprocess.Popen`
	offtarget server process, as returned by `launch_offtarget_server`

    Returns
    -------
    `subprocess.Popen`

    Returns `offtarget_proc` if the process is running, else return `None`
    """

    if offtarget_proc is None:
        return None

    if offtarget_proc.poll() is not None:
        log.error('offtarget server exited unexpectedly with code '
                  '{}\n\n'.format(offtarget_proc.returncode))

        return None
    else:
        return offtarget_proc


def check_offtarget_running():
    """
    Check to see if an offtarget server that we didn't start is
    running

    """

    try:
        get_offtargets(["ACGT" * 5], 5, 9, 18)
        return True
    except ConnectionError:
        return False

#+END_SRC




** =parse_offtarget_server_response=
The =special_ops_crispr_tools/offtarget= server returns an HTTP request with the off targets matches formatted like this:

#+BEGIN_EXAMPLE
'AAAAAAAAAAAAAAAAAAAA true\nGGGGGGGGGGGGGGGGGGGG false\nACTAGCCCCAATTTACGTCT false\n'
#+END_EXAMPLE

Here the sites are the CRISPR sites we asked about, and the text
=true= and =false= indicates whether or not the site matched an
offtarget.

#+NAME: doc:parse_offtarget_server_response
#+BEGIN_SRC org
Parse the HTTP request returned from the off target server and return
which CRISPR sites were filtered.
#+END_SRC

#+BEGIN_SRC python
def parse_offtarget_server_response(response):
    """
    <<doc:parse_offtarget_server_response>>

    Parameters
    ----------
    response : `requests.Response`
	response from offtarget server, as returned by
	`get_offtargets`

    Returns
    -------
    offtargets : defaultdict

    dictionary where `offtargets[site] == True` if `site` is an
    offtarget
    """

    offtargets = defaultdict(bool)

    for line in response.text.split('\n'):
        if line[-4:] == 'true':
            offtargets[line[0:20]] = True

    return offtargets
#+END_SRC

** Command line interface
#+BEGIN_SRC python
def main():
    parser = argparse.ArgumentParser(description='Filter guides in a '
                                     'sites-to-reads file based on offtargets '
                                     'and quality')

    parser.add_argument('input', type=str, help='input sites-to-reads file to '
                        'filter. Generated by crispr_sites -r')

    parser.add_argument('--filtered_explanation', type=str,
                        help='output file listing which guides were '
                        'disqualified and why. CSV format.')

    offtarget_group = parser.add_argument_group('offtarget filtering',
                                                'options to filter offtargets')
    
    offtarget_group.add_argument('--offtarget', type=str,
			         help='File containing off target CRISPR sites, as '
			         'generated by crispr_sites')

    offtarget_group.add_argument('--offtarget_radius', type=str, default='5_10_20',
			         help='Radius used for matching an off target. '
                                 'Specify this as L_M_N which means remove a '
                                 'guide for hitting an off target if L, M, N '
                                 'nucleotides in the first 5, 10 and 20 '
                                 'positions of the guide, respectively, match '
			         'the off target. e.g., 5_10_20 to require '
                                 'perfect matches; 5_9_18 to allow up to one '
                                 'mismatch in positions 6-10 positions and to '
                                 'allow up to 2 mismatches in the last 10 '
                                 'positions')

    ontarget_group = parser.add_argument_group('ontarget filtering',
                                               'options to filter ontargets')

    ontarget_group.add_argument('--ontarget', type=str,
                                help='File containing ontarget CRISPR sites, as '
                                'generated by crispr_sites')

    ontarget_group.add_argument('--ontarget_radius', type=str, default='5_10_20',
                                help='Radius used for matching ontargets. Same '
                                'format as --offtarget_radius.')
    
    filtering_group = parser.add_argument_group('quality filtering',
						'options for how guides are '
                                                'filtered for poor structure '
                                                'reasons')

    filtering_group.add_argument('--gc_freq_min', type=int, default=5,
				 help='filter guide if # of Gs or Cs is '
				 'strictly less than this number')

    filtering_group.add_argument('--gc_freq_max', type=int, default=15,
				 help='filter guide if # of Gs or Cs is '
				 'strictly greater than this number')

    filtering_group.add_argument('--homopolymer', type=int, default=5,
				 help='filter guide if strictly more than '
				 'this number of a single consecutive '
				 'nucleotide appears, e.g., AAAAA')

    filtering_group.add_argument('--dinucleotide_repeats', type=int, default=3,
				 help='filter guide if strictly more than '
				 'this number of a single dinucleotide repeats '
				 'occur, e.g. ATATAT')

    filtering_group.add_argument('--hairpin_min_inner', type=int, default=3,
				 help='filter guide if a hairpin occurs with >='
				 'this inner hairpin spacing, e.g., '
				 'oooooIIIooooo, where the o are reverse '
				 'complements and III is the inner hairpin '
				 'spacing')

    filtering_group.add_argument('--hairpin_min_outer', type=int, default=5,
				 help='filter guide if a hairpin occurs with >='
				 'this outer hairpin width, e.g., '
				 'oooooIIIooooo, where the o are reverse '
				 'complements and ooooo is the outer hairpin')


    start_time = datetime.now()

    args = parser.parse_args()

    filter_parms = { 'gc_frequency': (args.gc_freq_min, args.gc_freq_max),
		     'homopolymer': args.homopolymer,
		     'dinucleotide_repeats': args.dinucleotide_repeats,
		     'hairpin': { 'min_inner': args.hairpin_min_inner,
				  'min_outer': args.hairpin_min_outer } }

    try:
        input_handle = open(args.input, 'r')
    except IOError:
        log.error('Error opening input file {}'.format(args.input))
        sys.exit(1)

    num_reads_line = input_handle.readline()

    # Parse how many reads are represented in the sites-to-reads file
    match = re.search(r': (\d)+', num_reads_line)
    if match is None:
        log.error('{} is missing the total number of reads on line 1, '
                  're-run crispr_sites -r'.format(args.input))
        sys.exit(1)

    num_reads = int(match.group(1))

    log.info('Reading in candidate guides from {}'.format(args.input))

    candidate_guides = []

    filtered_guides = {}
    
    for line in tqdm(input_handle.readlines()):
        candidate_guides.append(line[0:20])

    initial_num_candidate_guides = len(candidate_guides)

    input_handle.close()

    # Ontarget filtering
    #
    # Note: ontarget filtering uses the offtarget server, but with a
    # list of ontargets
    if args.ontarget is not None:
        log.info('Launching ontarget filtering server')
        ontarget_proc = launch_offtarget_server(args.ontarget)

        if ontarget_proc is None:
            log.error('Error starting ontarget filtering server')
            sys.exit(1)

        # Catch SIGTERM/SIGINT to shutdown the offtarget server
        def ontarget_handler(signal, frame):
            global ontarget_proc
            log.info('Killing ontarget server')
            ontarget_proc.kill()
            sys.exit(1)

        signal.signal(signal.SIGINT, ontarget_handler)
        signal.signal(signal.SIGTERM, ontarget_handler)

        log.info('Filtering ontarget guides')

        try:
            c5, c10, c20 = map(int, args.ontarget_radius.split('_'))
        except ValueError:
            log.error(f"Invalid ontarget radius string {args.ontarget_radius}")
            sys.exit(1)

        try:
            ontargets = get_offtargets(
                candidate_guides, c5, c10, c20)
        except:
            log.error(f"Error getting offtargets from offtarget server")
            raise

        log.info('Updating list of candidate guides')
        for guide in tqdm(candidate_guides):
            if guide not in ontargets:
                filtered_guides[guide] = ('not ontarget in '
                                          '{}'.format(args.ontarget))

        candidate_guides = list(ontargets)
                
        log.info('{} guides were not ontargets '
                 'in {}'.format(len(filtered_guides), args.ontarget))
        log.info('Killing ontarget server')
        ontarget_proc.kill()            
    else:
        log.info('ontarget file not specified with --ontarget, will not '
                 'perform any ontarget filtering')
        
    if args.offtarget is not None:
        log.info('Launching offtarget filtering server, this may take a while')
        offtarget_proc = launch_offtarget_server(args.offtarget)

        if offtarget_proc is None:
            log.error("Error starting offtarget filtering server")
            sys.exit(1)
    
        # Catch SIGTERM/SIGINT to shutdown the offtarget server
        def handler(signal, frame):
            global offtarget_proc
            log.info('Killing offtarget server')
            offtarget_proc.kill()
            sys.exit(1)

        signal.signal(signal.SIGINT, handler)
        signal.signal(signal.SIGTERM, handler)

        log.info('Filtering offtarget guides')

        try:
            c5, c10, c20 = map(int, args.ontarget_radius.split('_'))
        except ValueError:
            log.error(f"Invalid ontarget radius string {args.ontarget_radius}")
            sys.exit(1)

        try:
            offtargets = get_offtargets(
                candidate_guides, c5, c10, c20)
        except:
            log.error(f"Error getting offtargets from offtarget server")
            raise

        num_filtered_before = len(filtered_guides)
        
        for guide in offtargets:
            filtered_guides[guide] = ('offtarget against '
                                      '{}'.format(args.offtarget))

        log.info('{} guides matched against offtargets '
                 'in {}'.format(len(filtered_guides) - num_filtered_before, args.offtarget))
        log.info('Killing offtarget server')
        offtarget_proc.kill()
            
        candidate_guides = [g for g in candidate_guides if g not in filtered_guides]            
    else:
        log.info('offtarget file not specified with --offtarget, will not '
                 'perform any offtarget filtering')

    # Do quality filtering
    log.info('Filtering guides for quality')

    filter_sites_poor_structure(candidate_guides, filtered_guides, filter_parms)

    log.info('Done filtering guides, removed {} out of {} '
             'guides'.format(len(filtered_guides), initial_num_candidate_guides))

    with open(args.input, 'r') as input_handle:
        # Write out first line always
        sys.stdout.write(input_handle.readline())

        for line in input_handle.readlines():
            if line[0:20] not in filtered_guides:
                sys.stdout.write(line)
        
        if args.filtered_explanation is not None:
            with open(args.filtered_explanation, 'w') as output_handle:
                output_handle.write('candidate guide, why it was filtered out\n')
                for guide in filtered_guides:
                    output_handle.write('{}, {}\n'.format(guide, filtered_guides[guide]))

if __name__ == '__main__':
    main()
#+END_SRC


